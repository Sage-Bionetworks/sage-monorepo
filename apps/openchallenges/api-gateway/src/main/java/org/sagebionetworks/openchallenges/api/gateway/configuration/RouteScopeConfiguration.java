package org.sagebionetworks.openchallenges.api.gateway.configuration;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import jakarta.annotation.PostConstruct;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Component;
import lombok.extern.slf4j.Slf4j;

/**
 * Configuration for route-to-scope mappings.
 * This configuration loads the route-scopes.yml file generated by OpenApiScopeMapper.
 */
@Slf4j
@Component
public class RouteScopeConfiguration {
  private static final ObjectMapper yamlMapper = new ObjectMapper(new YAMLFactory());

  private Map<String, RouteConfig> routeScopes;

  @PostConstruct
  public void loadRouteScopeConfig() {
    try {
      ClassPathResource resource = new ClassPathResource("route-scopes.yml");
      if (!resource.exists()) {
        log.warn("route-scopes.yml not found in classpath. No route scope mappings will be available.");
        log.warn("To generate route scopes, run: nx run openchallenges-api-gateway:generateRouteScopes");
        this.routeScopes = Map.of();
        return;
      }

      try (InputStream inputStream = resource.getInputStream()) {
        Map<String, Object> config = yamlMapper.readValue(inputStream, Map.class);
        this.routeScopes = parseRouteScopeConfig(config);
        log.info("Loaded {} route scope mappings from route-scopes.yml", this.routeScopes.size());
      }
    } catch (IOException e) {
      log.error("Failed to load route-scopes.yml", e);
      this.routeScopes = Map.of();
    }
  }

  @SuppressWarnings("unchecked")
  private Map<String, RouteConfig> parseRouteScopeConfig(Map<String, Object> config) {
    // Navigate to openchallenges.gateway.route-scopes
    Map<String, Object> openchallenges = (Map<String, Object>) config.get("openchallenges");
    if (openchallenges == null) {
      return Map.of();
    }

    Map<String, Object> gateway = (Map<String, Object>) openchallenges.get("gateway");
    if (gateway == null) {
      return Map.of();
    }

    Map<String, Map<String, Object>> scopes = (Map<String, Map<String, Object>>) gateway.get("route-scopes");
    if (scopes == null) {
      return Map.of();
    }

    // Convert to RouteConfig objects
    return scopes.entrySet().stream()
      .collect(java.util.stream.Collectors.toMap(
        Map.Entry::getKey,
        entry -> {
          RouteConfig routeConfig = new RouteConfig();
          List<String> scopeList = (List<String>) entry.getValue().get("scopes");
          routeConfig.setScopes(scopeList != null ? scopeList : List.of());
          
          // Parse anonymous access flag
          Boolean anonymousAccess = (Boolean) entry.getValue().get("anonymousAccess");
          routeConfig.setAnonymousAccess(anonymousAccess != null && anonymousAccess);
          
          return routeConfig;
        }
      ));
  }

  public Map<String, RouteConfig> getRouteScopes() {
    return routeScopes != null ? routeScopes : Map.of();
  }

  public void setRouteScopes(Map<String, RouteConfig> routeScopes) {
    this.routeScopes = routeScopes;
  }

  /**
   * Get the required scopes for a given HTTP method and path.
   *
   * @param method HTTP method (GET, POST, etc.)
   * @param path   URL path
   * @return List of required scopes, or empty list if no scopes required
   */
  public List<String> getScopesForRoute(String method, String path) {
    if (routeScopes == null) {
      return List.of();
    }
    
    String routeKey = method.toUpperCase() + " " + path;
    RouteConfig config = routeScopes.get(routeKey);
    
    if (config != null && config.getScopes() != null) {
      return config.getScopes();
    }
    
    // If exact match fails, try pattern matching for parameterized routes
    for (Map.Entry<String, RouteConfig> entry : routeScopes.entrySet()) {
      String pattern = entry.getKey();
      if (matchesPattern(routeKey, pattern)) {
        RouteConfig patternConfig = entry.getValue();
        if (patternConfig != null && patternConfig.getScopes() != null) {
          log.debug("Matched route pattern '{}' for request '{}'", pattern, routeKey);
          return patternConfig.getScopes();
        }
      }
    }
    
    return List.of();
  }

  /**
   * Check if a route key matches a pattern with path parameters.
   * For example: "POST /api/v1/challenges/1/contributions" matches "POST /api/v1/challenges/{challengeId}/contributions"
   */
  private boolean matchesPattern(String routeKey, String pattern) {
    String[] routeParts = routeKey.split(" ", 2);
    String[] patternParts = pattern.split(" ", 2);
    
    if (routeParts.length != 2 || patternParts.length != 2) {
      return false;
    }
    
    // Method must match exactly
    if (!routeParts[0].equals(patternParts[0])) {
      return false;
    }
    
    // Check path with parameter substitution
    return matchesPathPattern(routeParts[1], patternParts[1]);
  }
  
  /**
   * Check if a path matches a pattern with path parameters.
   * Parameters are indicated by curly braces like {challengeId}
   */
  private boolean matchesPathPattern(String path, String pattern) {
    String[] pathSegments = path.split("/");
    String[] patternSegments = pattern.split("/");
    
    if (pathSegments.length != patternSegments.length) {
      return false;
    }
    
    for (int i = 0; i < pathSegments.length; i++) {
      String pathSegment = pathSegments[i];
      String patternSegment = patternSegments[i];
      
      // If pattern segment is a parameter (starts and ends with {}), it matches any value
      if (patternSegment.startsWith("{") && patternSegment.endsWith("}")) {
        continue;
      }
      
      // Otherwise, segments must match exactly
      if (!pathSegment.equals(patternSegment)) {
        return false;
      }
    }
    
    return true;
  }

  /**
   * Check if a route allows anonymous access.
   *
   * @param method HTTP method (GET, POST, etc.)
   * @param path   URL path
   * @return true if the route allows anonymous access, false otherwise
   */
  public boolean isAnonymousAccessAllowed(String method, String path) {
    if (routeScopes == null) {
      return false;
    }
    
    String routeKey = method.toUpperCase() + " " + path;
    RouteConfig config = routeScopes.get(routeKey);
    
    if (config != null) {
      return config.isAnonymousAccess();
    }
    
    // If exact match fails, try pattern matching for parameterized routes
    for (Map.Entry<String, RouteConfig> entry : routeScopes.entrySet()) {
      String pattern = entry.getKey();
      if (matchesPattern(routeKey, pattern)) {
        RouteConfig patternConfig = entry.getValue();
        if (patternConfig != null) {
          return patternConfig.isAnonymousAccess();
        }
      }
    }
    
    return false;
  }

  public static class RouteConfig {
    private List<String> scopes;
    private boolean anonymousAccess = false;

    public List<String> getScopes() {
      return scopes;
    }

    public void setScopes(List<String> scopes) {
      this.scopes = scopes;
    }

    public boolean isAnonymousAccess() {
      return anonymousAccess;
    }

    public void setAnonymousAccess(boolean anonymousAccess) {
      this.anonymousAccess = anonymousAccess;
    }
  }
}
