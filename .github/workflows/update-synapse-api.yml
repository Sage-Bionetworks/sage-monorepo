name: Update Synapse API description and generated artifacts

on:
  push:
    branches:
      - synapse/workflow-container-root # trigger workflow when changes are pushed to this maintenance branch
  schedule:
    # Run daily at 9 AM UTC (4 AM EST, 1 AM PST)
    - cron: '0 9 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: update-synapse-api
  cancel-in-progress: false

env:
  # NOTE: The following secrets must be defined in the repository or organization settings.
  # Some static analyzers may flag them as "Context access might be invalid" even though this
  # is valid GitHub Actions syntax. Leave as-is unless the secret names change.
  NX_BRANCH: ${{ github.ref_name }}
  NX_CLOUD_ENCRYPTION_KEY: ${{ secrets.NX_CLOUD_ENCRYPTION_KEY }}

jobs:
  extract-devcontainer-image:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.devcontainer.outputs.image }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - id: devcontainer
        name: Read .devcontainer/devcontainer.json
        run: echo "image=$(jq -r '.image' .devcontainer/devcontainer.json)" >> $GITHUB_OUTPUT

  update-synapse-api:
    runs-on: ubuntu-latest
    needs: extract-devcontainer-image
    defaults:
      run:
        # Use a login Bash shell so profile scripts (/etc/profile, /etc/bash.bashrc, and user profile)
        # populate PATH with user-local bin directories (e.g. /home/ubuntu/.local/bin) where the devcontainer
        # installs tools like `uv`. Without `-l`, a non-login, non-interactive shell would often miss those
        # PATH entries and `uv` (and similar user-scoped tools) could be reported as "command not found".
        # NOTE: The devcontainer's ~/.bashrc sources dev-env.sh only AFTER a non-interactive guard
        # (e.g. a pattern like: [ -z "$PS1" ] && return). GitHub Actions steps run in a non-interactive
        # shell, so that guard causes an early return and dev-env.sh is NOT sourced automatically.
        # Therefore we still explicitly source dev-env.sh in a step to obtain functions like
        # workspace-install. The login shell here is strictly for PATH hydration, not for loading
        # those functions. This keeps PATH setup minimal and avoids manual PATH surgery.
        shell: bash -l {0}
    env:
      # NOTE: See comment above about secret name validation.
      # # Disable Nx Cloud usage for this workflow to avoid consuming tokens / network calls when
      # # simply regenerating artifacts. If later we want hashing/distributed features, remove this.
      # NX_NO_CLOUD: 'true'
      NX_CLOUD_ACCESS_TOKEN: ${{ secrets.NX_CLOUD_ACCESS_TOKEN_READ_WRITE }}

    container:
      image: ${{ needs.extract-devcontainer-image.outputs.image }}
      # NOTE: We intentionally run with the image's default user (likely root) here.
      # Setting --user ubuntu caused actions/checkout to fail writing state files under $RUNNER_TEMP
      # (EACCES opening /__w/_temp/_runner_file_commands/save_state_*). GitHub mounts /__w with
      # ownership that assumes the container user can write. Overriding to a non-root user without
      # adjusting ownership (chown) breaks any action that uses file command APIs. If we later need
      # to run generation as a non-root user, prefer either:
      #  1. A step wrapper: sudo -u ubuntu bash -lc '...'; or
      #  2. A custom image whose default USER already matches the desired UID and has correct perms.
      # Leaving off --user restores normal permissions and resolves the checkout EACCES error.

    steps:
      - name: Give ubuntu ownership of the workspace and temp dirs
        run: |
          chown -R ubuntu:ubuntu "$RUNNER_TEMP" "$RUNNER_TOOL_CACHE" 2>/dev/null || true
          chmod -R u+w "$RUNNER_TEMP"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare the workspace
        run: |
          su -l ubuntu -c 'bash -lc "
            . ./dev-env.sh
            workspace-install
          "'

      # - name: Build API description & regenerate generated projects
      #   run: |
      #     . ./dev-env.sh
      #     set -euo pipefail
      #     echo 'ðŸ”„ Building API description (includes downloading latest OpenAPI specification)...'
      #     nx build synapse-api-description
      #     echo 'ðŸ”„ Regenerating synapse-* generated projects (clients, docs, etc.)...'
      #     nx run-many --target=generate --projects='synapse-*'

      # - name: Create or update Pull Request
      #   uses: peter-evans/create-pull-request@v7
      #   with:
      #     branch: synapse/update-synapse-api
      #     delete-branch: true
      #     title: 'chore(synapse): update Synapse API description and generated artifacts'
      #     commit-message: 'chore(synapse): update Synapse API description and generated artifacts'
      #     body: |
      #       ## Description

      #       This is an automated update triggered by changes detected in the Synapse OpenAPI specification.
      #       The workflow downloads the latest specification and regenerates dependent generated projects (clients, docs, etc.) to keep them in sync.

      #       ## Review checklist

      #       - [ ] Verify that the API changes are expected
      #       - [ ] Check that generated artifacts build/compile successfully
      #       - [ ] Run tests to ensure compatibility
      #       - [ ] Review any breaking changes in the API
