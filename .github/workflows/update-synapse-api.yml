name: Update Synapse API description and generated artifacts

on:
  schedule:
    # Run daily at 9 AM UTC (4 AM EST, 1 AM PST)
    - cron: '0 9 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: update-synapse-api
  cancel-in-progress: false

env:
  NX_BRANCH: ${{ github.ref_name }}
  NX_CLOUD_ENCRYPTION_KEY: ${{ secrets.NX_CLOUD_ENCRYPTION_KEY }}

jobs:
  extract-devcontainer-image:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.devcontainer.outputs.image }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - id: devcontainer
        name: Read .devcontainer/devcontainer.json
        run: echo "image=$(jq -r '.image' .devcontainer/devcontainer.json)" >> $GITHUB_OUTPUT

  update-synapse-api:
    runs-on: ubuntu-latest
    needs: extract-devcontainer-image
    defaults:
      run:
        # Use a login Bash shell so profile scripts (/etc/profile, /etc/bash.bashrc, and user profile)
        # populate PATH with user-local bin directories (e.g. /home/ubuntu/.local/bin) where the devcontainer
        # installs tools like `uv`. Without `-l`, a non-login, non-interactive shell would often miss those
        # PATH entries and `uv` (and similar user-scoped tools) could be reported as "command not found".
        # NOTE: The devcontainer's ~/.bashrc sources dev-env.sh only AFTER a non-interactive guard
        # (e.g. a pattern like: [ -z "$PS1" ] && return). GitHub Actions steps run in a non-interactive
        # shell, so that guard causes an early return and dev-env.sh is NOT sourced automatically.
        # Therefore we still explicitly source dev-env.sh in a step to obtain functions like
        # workspace-install. The login shell here is strictly for PATH hydration, not for loading
        # those functions. This keeps PATH setup minimal and avoids manual PATH surgery.
        shell: bash -l {0}
    env:
      # # Disable Nx Cloud usage for this workflow to avoid consuming tokens / network calls when
      # # simply regenerating artifacts. If later we want hashing/distributed features, remove this.
      # NX_NO_CLOUD: 'true'
      NX_CLOUD_ACCESS_TOKEN: ${{ secrets.NX_CLOUD_ACCESS_TOKEN_READ_WRITE }}

    container:
      image: ${{ needs.extract-devcontainer-image.outputs.image }}
      options: --user ubuntu

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare the workspace
        run: |
          . ./dev-env.sh
          workspace-install

      - name: Build API description & regenerate generated projects
        run: |
          . ./dev-env.sh
          set -euo pipefail
          echo 'ðŸ”„ Building API description (includes downloading latest OpenAPI specification)...'
          nx build synapse-api-description
          echo 'ðŸ”„ Regenerating synapse-* generated projects (clients, docs, etc.)...'
          nx run-many --target=generate --projects='synapse-*'

      - name: Create or update Pull Request
        uses: peter-evans/create-pull-request@v7
        with:
          branch: synapse/update-synapse-api
          title: 'chore(synapse): update Synapse API description and generated artifacts'
          commit-message: 'chore(synapse): update Synapse API description and generated artifacts'
          body: |
            ## Description

            This is an automated update triggered by changes detected in the Synapse OpenAPI specification.
            The workflow downloads the latest specification and regenerates dependent generated projects (clients, docs, etc.) to keep them in sync.

            ## Review checklist

            - [ ] Verify that the API changes are expected
            - [ ] Check that generated artifacts build/compile successfully
            - [ ] Run tests to ensure compatibility
            - [ ] Review any breaking changes in the API
