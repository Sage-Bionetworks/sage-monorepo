/**
 * Synapse REST API
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs';

// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionCreateDiscussionReply } from '../model/org-sagebionetworks-repo-model-discussion-create-discussion-reply';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionCreateDiscussionThread } from '../model/org-sagebionetworks-repo-model-discussion-create-discussion-thread';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionDiscussionFilter } from '../model/org-sagebionetworks-repo-model-discussion-discussion-filter';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionDiscussionReplyBundle } from '../model/org-sagebionetworks-repo-model-discussion-discussion-reply-bundle';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionDiscussionReplyOrder } from '../model/org-sagebionetworks-repo-model-discussion-discussion-reply-order';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionDiscussionSearchRequest } from '../model/org-sagebionetworks-repo-model-discussion-discussion-search-request';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionDiscussionSearchResponse } from '../model/org-sagebionetworks-repo-model-discussion-discussion-search-response';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle } from '../model/org-sagebionetworks-repo-model-discussion-discussion-thread-bundle';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionDiscussionThreadOrder } from '../model/org-sagebionetworks-repo-model-discussion-discussion-thread-order';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionEntityThreadCounts } from '../model/org-sagebionetworks-repo-model-discussion-entity-thread-counts';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionForum } from '../model/org-sagebionetworks-repo-model-discussion-forum';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionMessageURL } from '../model/org-sagebionetworks-repo-model-discussion-message-url';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionReplyCount } from '../model/org-sagebionetworks-repo-model-discussion-reply-count';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionThreadCount } from '../model/org-sagebionetworks-repo-model-discussion-thread-count';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionUpdateReplyMessage } from '../model/org-sagebionetworks-repo-model-discussion-update-reply-message';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionUpdateThreadMessage } from '../model/org-sagebionetworks-repo-model-discussion-update-thread-message';
// @ts-ignore
import { OrgSagebionetworksRepoModelDiscussionUpdateThreadTitle } from '../model/org-sagebionetworks-repo-model-discussion-update-thread-title';
// @ts-ignore
import { OrgSagebionetworksRepoModelEntityIdList } from '../model/org-sagebionetworks-repo-model-entity-id-list';
// @ts-ignore
import { OrgSagebionetworksRepoModelPaginatedIds } from '../model/org-sagebionetworks-repo-model-paginated-ids';
// @ts-ignore
import { PaginatedResultsOfDiscussionReplyBundle } from '../model/paginated-results-of-discussion-reply-bundle';
// @ts-ignore
import { PaginatedResultsOfDiscussionThreadBundle } from '../model/paginated-results-of-discussion-thread-bundle';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

@Injectable({
  providedIn: 'root',
})
export class DiscussionServicesService {
  protected basePath = 'https://repo-prod.prod.sagebase.org';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();
  public encoder: HttpParameterCodec;

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration: Configuration,
  ) {
    if (configuration) {
      this.configuration = configuration;
    }
    if (typeof this.configuration.basePath !== 'string') {
      const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;
      if (firstBasePath != undefined) {
        basePath = firstBasePath;
      }

      if (typeof basePath !== 'string') {
        basePath = this.basePath;
      }
      this.configuration.basePath = basePath;
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
  }

  // @ts-ignore
  private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value);
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
    }
    return httpParams;
  }

  private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
    if (value == null) {
      return httpParams;
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        (value as any[]).forEach(
          (elem) => (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key)),
        );
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));
        } else {
          throw Error('key may not be null if value is Date');
        }
      } else {
        Object.keys(value).forEach(
          (k) =>
            (httpParams = this.addToHttpParamsRecursive(
              httpParams,
              value[k],
              key != null ? `${key}[${k}]` : k,
            )),
        );
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value);
    } else {
      throw Error('key may not be null if value is not object or array');
    }
    return httpParams;
  }

  /**
   * @param replyId - the ID of the reply being marked as deleted
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteRepoV1ReplyReplyId(
    replyId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<any>;
  public deleteRepoV1ReplyReplyId(
    replyId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<HttpResponse<any>>;
  public deleteRepoV1ReplyReplyId(
    replyId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<HttpEvent<any>>;
  public deleteRepoV1ReplyReplyId(
    replyId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<any> {
    if (replyId === null || replyId === undefined) {
      throw new Error(
        'Required parameter replyId was null or undefined when calling deleteRepoV1ReplyReplyId.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/reply/${this.configuration.encodeParam({ name: 'replyId', value: replyId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`;
    return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * @param threadId - the ID of the thread being marked as deleted
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteRepoV1ThreadThreadId(
    threadId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<any>;
  public deleteRepoV1ThreadThreadId(
    threadId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<HttpResponse<any>>;
  public deleteRepoV1ThreadThreadId(
    threadId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<HttpEvent<any>>;
  public deleteRepoV1ThreadThreadId(
    threadId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<any> {
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling deleteRepoV1ThreadThreadId.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/thread/${this.configuration.encodeParam({ name: 'threadId', value: threadId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`;
    return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * @param limit - Limits the size of the page returned. For example, a page size of 10 require limit &#x3D; 10. The maximum Limit for this call is 20.
   * @param offset - The index of the pagination offset. For a page size of 10, the first page would be at offset &#x3D; 0, and the second page would be at offset &#x3D; 10.
   * @param id - The request entityId
   * @param sort - The field to sort the resulting threads on. Available options: ,&lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.discussion.DiscussionThreadOrder}\&quot;&gt;,DiscussionThreadOrder,&lt;/a&gt;,.
   * @param ascending - The direction of sort: true for ascending, and false for descending
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRepoV1EntityIdThreads(
    limit: number,
    offset: number,
    id: string,
    sort?: OrgSagebionetworksRepoModelDiscussionDiscussionThreadOrder,
    ascending?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<PaginatedResultsOfDiscussionThreadBundle>;
  public getRepoV1EntityIdThreads(
    limit: number,
    offset: number,
    id: string,
    sort?: OrgSagebionetworksRepoModelDiscussionDiscussionThreadOrder,
    ascending?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<PaginatedResultsOfDiscussionThreadBundle>>;
  public getRepoV1EntityIdThreads(
    limit: number,
    offset: number,
    id: string,
    sort?: OrgSagebionetworksRepoModelDiscussionDiscussionThreadOrder,
    ascending?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<PaginatedResultsOfDiscussionThreadBundle>>;
  public getRepoV1EntityIdThreads(
    limit: number,
    offset: number,
    id: string,
    sort?: OrgSagebionetworksRepoModelDiscussionDiscussionThreadOrder,
    ascending?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (limit === null || limit === undefined) {
      throw new Error(
        'Required parameter limit was null or undefined when calling getRepoV1EntityIdThreads.',
      );
    }
    if (offset === null || offset === undefined) {
      throw new Error(
        'Required parameter offset was null or undefined when calling getRepoV1EntityIdThreads.',
      );
    }
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getRepoV1EntityIdThreads.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (limit !== undefined && limit !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>limit, 'limit');
    }
    if (offset !== undefined && offset !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>offset,
        'offset',
      );
    }
    if (sort !== undefined && sort !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>sort, 'sort');
    }
    if (ascending !== undefined && ascending !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>ascending,
        'ascending',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/entity/${this.configuration.encodeParam({ name: 'id', value: id, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/threads`;
    return this.httpClient.request<PaginatedResultsOfDiscussionThreadBundle>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param forumId - The ID of the forum.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRepoV1ForumForumId(
    forumId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionForum>;
  public getRepoV1ForumForumId(
    forumId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionForum>>;
  public getRepoV1ForumForumId(
    forumId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionForum>>;
  public getRepoV1ForumForumId(
    forumId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (forumId === null || forumId === undefined) {
      throw new Error(
        'Required parameter forumId was null or undefined when calling getRepoV1ForumForumId.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/forum/${this.configuration.encodeParam({ name: 'forumId', value: forumId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionForum>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param limit - Limits the size of the page returned. For example, a page size of 10 require limit &#x3D; 10. The maximum Limit for this call is 100.
   * @param offset - The index of the pagination offset. For a page size of 10, the first page would be at offset &#x3D; 0, and the second page would be at offset &#x3D; 10.
   * @param forumId - The forum ID to which the returning mederators belong
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRepoV1ForumForumIdModerators(
    limit: number,
    offset: number,
    forumId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelPaginatedIds>;
  public getRepoV1ForumForumIdModerators(
    limit: number,
    offset: number,
    forumId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelPaginatedIds>>;
  public getRepoV1ForumForumIdModerators(
    limit: number,
    offset: number,
    forumId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelPaginatedIds>>;
  public getRepoV1ForumForumIdModerators(
    limit: number,
    offset: number,
    forumId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (limit === null || limit === undefined) {
      throw new Error(
        'Required parameter limit was null or undefined when calling getRepoV1ForumForumIdModerators.',
      );
    }
    if (offset === null || offset === undefined) {
      throw new Error(
        'Required parameter offset was null or undefined when calling getRepoV1ForumForumIdModerators.',
      );
    }
    if (forumId === null || forumId === undefined) {
      throw new Error(
        'Required parameter forumId was null or undefined when calling getRepoV1ForumForumIdModerators.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (limit !== undefined && limit !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>limit, 'limit');
    }
    if (offset !== undefined && offset !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>offset,
        'offset',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/forum/${this.configuration.encodeParam({ name: 'forumId', value: forumId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/moderators`;
    return this.httpClient.request<OrgSagebionetworksRepoModelPaginatedIds>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param filter - Filter deleted/ not deleted threads. Available options: ,&lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.discussion.DiscussionFilter}\&quot;&gt;,DiscussionFilter,&lt;/a&gt;,.
   * @param forumId - The forum ID to which the returning threads belong
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRepoV1ForumForumIdThreadcount(
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    forumId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionThreadCount>;
  public getRepoV1ForumForumIdThreadcount(
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    forumId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionThreadCount>>;
  public getRepoV1ForumForumIdThreadcount(
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    forumId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionThreadCount>>;
  public getRepoV1ForumForumIdThreadcount(
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    forumId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (filter === null || filter === undefined) {
      throw new Error(
        'Required parameter filter was null or undefined when calling getRepoV1ForumForumIdThreadcount.',
      );
    }
    if (forumId === null || forumId === undefined) {
      throw new Error(
        'Required parameter forumId was null or undefined when calling getRepoV1ForumForumIdThreadcount.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (filter !== undefined && filter !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>filter,
        'filter',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/forum/${this.configuration.encodeParam({ name: 'forumId', value: forumId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/threadcount`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionThreadCount>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param limit - Limits the size of the page returned. For example, a page size of 10 require limit &#x3D; 10. The maximum Limit for this call is 20.
   * @param offset - The index of the pagination offset. For a page size of 10, the first page would be at offset &#x3D; 0, and the second page would be at offset &#x3D; 10.
   * @param filter - Filter deleted/ not deleted threads. Available options: ,&lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.discussion.DiscussionFilter}\&quot;&gt;,DiscussionFilter,&lt;/a&gt;,.
   * @param forumId - The forum ID to which the returning threads belong
   * @param sort - The field to sort the resulting threads on. Available options: ,&lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.discussion.DiscussionThreadOrder}\&quot;&gt;,DiscussionThreadOrder,&lt;/a&gt;,.
   * @param ascending - The direction of sort: true for ascending, and false for descending
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRepoV1ForumForumIdThreads(
    limit: number,
    offset: number,
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    forumId: string,
    sort?: OrgSagebionetworksRepoModelDiscussionDiscussionThreadOrder,
    ascending?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<PaginatedResultsOfDiscussionThreadBundle>;
  public getRepoV1ForumForumIdThreads(
    limit: number,
    offset: number,
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    forumId: string,
    sort?: OrgSagebionetworksRepoModelDiscussionDiscussionThreadOrder,
    ascending?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<PaginatedResultsOfDiscussionThreadBundle>>;
  public getRepoV1ForumForumIdThreads(
    limit: number,
    offset: number,
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    forumId: string,
    sort?: OrgSagebionetworksRepoModelDiscussionDiscussionThreadOrder,
    ascending?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<PaginatedResultsOfDiscussionThreadBundle>>;
  public getRepoV1ForumForumIdThreads(
    limit: number,
    offset: number,
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    forumId: string,
    sort?: OrgSagebionetworksRepoModelDiscussionDiscussionThreadOrder,
    ascending?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (limit === null || limit === undefined) {
      throw new Error(
        'Required parameter limit was null or undefined when calling getRepoV1ForumForumIdThreads.',
      );
    }
    if (offset === null || offset === undefined) {
      throw new Error(
        'Required parameter offset was null or undefined when calling getRepoV1ForumForumIdThreads.',
      );
    }
    if (filter === null || filter === undefined) {
      throw new Error(
        'Required parameter filter was null or undefined when calling getRepoV1ForumForumIdThreads.',
      );
    }
    if (forumId === null || forumId === undefined) {
      throw new Error(
        'Required parameter forumId was null or undefined when calling getRepoV1ForumForumIdThreads.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (limit !== undefined && limit !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>limit, 'limit');
    }
    if (offset !== undefined && offset !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>offset,
        'offset',
      );
    }
    if (sort !== undefined && sort !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>sort, 'sort');
    }
    if (ascending !== undefined && ascending !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>ascending,
        'ascending',
      );
    }
    if (filter !== undefined && filter !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>filter,
        'filter',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/forum/${this.configuration.encodeParam({ name: 'forumId', value: forumId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/threads`;
    return this.httpClient.request<PaginatedResultsOfDiscussionThreadBundle>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param projectId - The ID of the project to which the forum belongs.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRepoV1ProjectProjectIdForum(
    projectId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionForum>;
  public getRepoV1ProjectProjectIdForum(
    projectId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionForum>>;
  public getRepoV1ProjectProjectIdForum(
    projectId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionForum>>;
  public getRepoV1ProjectProjectIdForum(
    projectId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (projectId === null || projectId === undefined) {
      throw new Error(
        'Required parameter projectId was null or undefined when calling getRepoV1ProjectProjectIdForum.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/project/${this.configuration.encodeParam({ name: 'projectId', value: projectId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/forum`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionForum>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param messageKey - DiscussionReplyBundle.messageKey
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRepoV1ReplyMessageUrl(
    messageKey: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionMessageURL>;
  public getRepoV1ReplyMessageUrl(
    messageKey: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionMessageURL>>;
  public getRepoV1ReplyMessageUrl(
    messageKey: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionMessageURL>>;
  public getRepoV1ReplyMessageUrl(
    messageKey: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (messageKey === null || messageKey === undefined) {
      throw new Error(
        'Required parameter messageKey was null or undefined when calling getRepoV1ReplyMessageUrl.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (messageKey !== undefined && messageKey !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>messageKey,
        'messageKey',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/reply/messageUrl`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionMessageURL>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param replyId - The ID of the reply being requested
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRepoV1ReplyReplyId(
    replyId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionDiscussionReplyBundle>;
  public getRepoV1ReplyReplyId(
    replyId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionDiscussionReplyBundle>>;
  public getRepoV1ReplyReplyId(
    replyId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionDiscussionReplyBundle>>;
  public getRepoV1ReplyReplyId(
    replyId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (replyId === null || replyId === undefined) {
      throw new Error(
        'Required parameter replyId was null or undefined when calling getRepoV1ReplyReplyId.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/reply/${this.configuration.encodeParam({ name: 'replyId', value: replyId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionDiscussionReplyBundle>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param messageKey
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRepoV1ThreadMessageUrl(
    messageKey: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionMessageURL>;
  public getRepoV1ThreadMessageUrl(
    messageKey: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionMessageURL>>;
  public getRepoV1ThreadMessageUrl(
    messageKey: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionMessageURL>>;
  public getRepoV1ThreadMessageUrl(
    messageKey: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (messageKey === null || messageKey === undefined) {
      throw new Error(
        'Required parameter messageKey was null or undefined when calling getRepoV1ThreadMessageUrl.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (messageKey !== undefined && messageKey !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>messageKey,
        'messageKey',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/thread/messageUrl`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionMessageURL>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param threadId - The ID of the thread being requested
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRepoV1ThreadThreadId(
    threadId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>;
  public getRepoV1ThreadThreadId(
    threadId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>>;
  public getRepoV1ThreadThreadId(
    threadId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>>;
  public getRepoV1ThreadThreadId(
    threadId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling getRepoV1ThreadThreadId.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/thread/${this.configuration.encodeParam({ name: 'threadId', value: threadId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param limit - Limits the size of the page returned. For example, a page size of 10 require limit &#x3D; 10. The maximum Limit for this call is 100.
   * @param offset - The index of the pagination offset. For a page size of 10, the first page would be at offset &#x3D; 0, and the second page would be at offset &#x3D; 10.
   * @param filter - Filter deleted/ not deleted replies. Available options: ,&lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.discussion.DiscussionFilter}\&quot;&gt;,DiscussionFilter,&lt;/a&gt;,.
   * @param threadId - The thread ID to which the returning replies belong
   * @param sort - The field to sort the resulting replies on. Available options: ,&lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.discussion.DiscussionReplyOrder}\&quot;&gt;,DiscussionReplyOrder,&lt;/a&gt;,.
   * @param ascending - The direction of sort: true for ascending, and false for descending
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRepoV1ThreadThreadIdReplies(
    limit: number,
    offset: number,
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    threadId: string,
    sort?: OrgSagebionetworksRepoModelDiscussionDiscussionReplyOrder,
    ascending?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<PaginatedResultsOfDiscussionReplyBundle>;
  public getRepoV1ThreadThreadIdReplies(
    limit: number,
    offset: number,
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    threadId: string,
    sort?: OrgSagebionetworksRepoModelDiscussionDiscussionReplyOrder,
    ascending?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<PaginatedResultsOfDiscussionReplyBundle>>;
  public getRepoV1ThreadThreadIdReplies(
    limit: number,
    offset: number,
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    threadId: string,
    sort?: OrgSagebionetworksRepoModelDiscussionDiscussionReplyOrder,
    ascending?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<PaginatedResultsOfDiscussionReplyBundle>>;
  public getRepoV1ThreadThreadIdReplies(
    limit: number,
    offset: number,
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    threadId: string,
    sort?: OrgSagebionetworksRepoModelDiscussionDiscussionReplyOrder,
    ascending?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (limit === null || limit === undefined) {
      throw new Error(
        'Required parameter limit was null or undefined when calling getRepoV1ThreadThreadIdReplies.',
      );
    }
    if (offset === null || offset === undefined) {
      throw new Error(
        'Required parameter offset was null or undefined when calling getRepoV1ThreadThreadIdReplies.',
      );
    }
    if (filter === null || filter === undefined) {
      throw new Error(
        'Required parameter filter was null or undefined when calling getRepoV1ThreadThreadIdReplies.',
      );
    }
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling getRepoV1ThreadThreadIdReplies.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (limit !== undefined && limit !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>limit, 'limit');
    }
    if (offset !== undefined && offset !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>offset,
        'offset',
      );
    }
    if (sort !== undefined && sort !== null) {
      localVarQueryParameters = this.addToHttpParams(localVarQueryParameters, <any>sort, 'sort');
    }
    if (ascending !== undefined && ascending !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>ascending,
        'ascending',
      );
    }
    if (filter !== undefined && filter !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>filter,
        'filter',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/thread/${this.configuration.encodeParam({ name: 'threadId', value: threadId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/replies`;
    return this.httpClient.request<PaginatedResultsOfDiscussionReplyBundle>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param filter - Filter deleted/ not deleted replies. Available options: ,&lt;a href&#x3D;\&quot;${org.sagebionetworks.repo.model.discussion.DiscussionFilter}\&quot;&gt;,DiscussionFilter,&lt;/a&gt;,.
   * @param threadId - The thread ID to which the returning replies belong
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRepoV1ThreadThreadIdReplycount(
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    threadId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionReplyCount>;
  public getRepoV1ThreadThreadIdReplycount(
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    threadId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionReplyCount>>;
  public getRepoV1ThreadThreadIdReplycount(
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    threadId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionReplyCount>>;
  public getRepoV1ThreadThreadIdReplycount(
    filter: OrgSagebionetworksRepoModelDiscussionDiscussionFilter,
    threadId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (filter === null || filter === undefined) {
      throw new Error(
        'Required parameter filter was null or undefined when calling getRepoV1ThreadThreadIdReplycount.',
      );
    }
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling getRepoV1ThreadThreadIdReplycount.',
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (filter !== undefined && filter !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>filter,
        'filter',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/thread/${this.configuration.encodeParam({ name: 'threadId', value: threadId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/replycount`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionReplyCount>(
      'get',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param orgSagebionetworksRepoModelEntityIdList
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public postRepoV1EntityThreadcounts(
    orgSagebionetworksRepoModelEntityIdList: OrgSagebionetworksRepoModelEntityIdList,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionEntityThreadCounts>;
  public postRepoV1EntityThreadcounts(
    orgSagebionetworksRepoModelEntityIdList: OrgSagebionetworksRepoModelEntityIdList,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionEntityThreadCounts>>;
  public postRepoV1EntityThreadcounts(
    orgSagebionetworksRepoModelEntityIdList: OrgSagebionetworksRepoModelEntityIdList,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionEntityThreadCounts>>;
  public postRepoV1EntityThreadcounts(
    orgSagebionetworksRepoModelEntityIdList: OrgSagebionetworksRepoModelEntityIdList,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (
      orgSagebionetworksRepoModelEntityIdList === null ||
      orgSagebionetworksRepoModelEntityIdList === undefined
    ) {
      throw new Error(
        'Required parameter orgSagebionetworksRepoModelEntityIdList was null or undefined when calling postRepoV1EntityThreadcounts.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/entity/threadcounts`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionEntityThreadCounts>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: orgSagebionetworksRepoModelEntityIdList,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param forumId The ID of the forum where the search is performed
   * @param orgSagebionetworksRepoModelDiscussionDiscussionSearchRequest
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public postRepoV1ForumForumIdSearch(
    forumId: string,
    orgSagebionetworksRepoModelDiscussionDiscussionSearchRequest: OrgSagebionetworksRepoModelDiscussionDiscussionSearchRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionDiscussionSearchResponse>;
  public postRepoV1ForumForumIdSearch(
    forumId: string,
    orgSagebionetworksRepoModelDiscussionDiscussionSearchRequest: OrgSagebionetworksRepoModelDiscussionDiscussionSearchRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionDiscussionSearchResponse>>;
  public postRepoV1ForumForumIdSearch(
    forumId: string,
    orgSagebionetworksRepoModelDiscussionDiscussionSearchRequest: OrgSagebionetworksRepoModelDiscussionDiscussionSearchRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionDiscussionSearchResponse>>;
  public postRepoV1ForumForumIdSearch(
    forumId: string,
    orgSagebionetworksRepoModelDiscussionDiscussionSearchRequest: OrgSagebionetworksRepoModelDiscussionDiscussionSearchRequest,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (forumId === null || forumId === undefined) {
      throw new Error(
        'Required parameter forumId was null or undefined when calling postRepoV1ForumForumIdSearch.',
      );
    }
    if (
      orgSagebionetworksRepoModelDiscussionDiscussionSearchRequest === null ||
      orgSagebionetworksRepoModelDiscussionDiscussionSearchRequest === undefined
    ) {
      throw new Error(
        'Required parameter orgSagebionetworksRepoModelDiscussionDiscussionSearchRequest was null or undefined when calling postRepoV1ForumForumIdSearch.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/forum/${this.configuration.encodeParam({ name: 'forumId', value: forumId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/search`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionDiscussionSearchResponse>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: orgSagebionetworksRepoModelDiscussionDiscussionSearchRequest,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param orgSagebionetworksRepoModelDiscussionCreateDiscussionReply
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public postRepoV1Reply(
    orgSagebionetworksRepoModelDiscussionCreateDiscussionReply: OrgSagebionetworksRepoModelDiscussionCreateDiscussionReply,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionDiscussionReplyBundle>;
  public postRepoV1Reply(
    orgSagebionetworksRepoModelDiscussionCreateDiscussionReply: OrgSagebionetworksRepoModelDiscussionCreateDiscussionReply,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionDiscussionReplyBundle>>;
  public postRepoV1Reply(
    orgSagebionetworksRepoModelDiscussionCreateDiscussionReply: OrgSagebionetworksRepoModelDiscussionCreateDiscussionReply,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionDiscussionReplyBundle>>;
  public postRepoV1Reply(
    orgSagebionetworksRepoModelDiscussionCreateDiscussionReply: OrgSagebionetworksRepoModelDiscussionCreateDiscussionReply,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (
      orgSagebionetworksRepoModelDiscussionCreateDiscussionReply === null ||
      orgSagebionetworksRepoModelDiscussionCreateDiscussionReply === undefined
    ) {
      throw new Error(
        'Required parameter orgSagebionetworksRepoModelDiscussionCreateDiscussionReply was null or undefined when calling postRepoV1Reply.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/reply`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionDiscussionReplyBundle>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: orgSagebionetworksRepoModelDiscussionCreateDiscussionReply,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param orgSagebionetworksRepoModelDiscussionCreateDiscussionThread
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public postRepoV1Thread(
    orgSagebionetworksRepoModelDiscussionCreateDiscussionThread: OrgSagebionetworksRepoModelDiscussionCreateDiscussionThread,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>;
  public postRepoV1Thread(
    orgSagebionetworksRepoModelDiscussionCreateDiscussionThread: OrgSagebionetworksRepoModelDiscussionCreateDiscussionThread,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>>;
  public postRepoV1Thread(
    orgSagebionetworksRepoModelDiscussionCreateDiscussionThread: OrgSagebionetworksRepoModelDiscussionCreateDiscussionThread,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>>;
  public postRepoV1Thread(
    orgSagebionetworksRepoModelDiscussionCreateDiscussionThread: OrgSagebionetworksRepoModelDiscussionCreateDiscussionThread,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (
      orgSagebionetworksRepoModelDiscussionCreateDiscussionThread === null ||
      orgSagebionetworksRepoModelDiscussionCreateDiscussionThread === undefined
    ) {
      throw new Error(
        'Required parameter orgSagebionetworksRepoModelDiscussionCreateDiscussionThread was null or undefined when calling postRepoV1Thread.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/thread`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>(
      'post',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: orgSagebionetworksRepoModelDiscussionCreateDiscussionThread,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param replyId - The ID of the reply being updated
   * @param orgSagebionetworksRepoModelDiscussionUpdateReplyMessage
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public putRepoV1ReplyReplyIdMessage(
    replyId: string,
    orgSagebionetworksRepoModelDiscussionUpdateReplyMessage: OrgSagebionetworksRepoModelDiscussionUpdateReplyMessage,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionDiscussionReplyBundle>;
  public putRepoV1ReplyReplyIdMessage(
    replyId: string,
    orgSagebionetworksRepoModelDiscussionUpdateReplyMessage: OrgSagebionetworksRepoModelDiscussionUpdateReplyMessage,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionDiscussionReplyBundle>>;
  public putRepoV1ReplyReplyIdMessage(
    replyId: string,
    orgSagebionetworksRepoModelDiscussionUpdateReplyMessage: OrgSagebionetworksRepoModelDiscussionUpdateReplyMessage,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionDiscussionReplyBundle>>;
  public putRepoV1ReplyReplyIdMessage(
    replyId: string,
    orgSagebionetworksRepoModelDiscussionUpdateReplyMessage: OrgSagebionetworksRepoModelDiscussionUpdateReplyMessage,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (replyId === null || replyId === undefined) {
      throw new Error(
        'Required parameter replyId was null or undefined when calling putRepoV1ReplyReplyIdMessage.',
      );
    }
    if (
      orgSagebionetworksRepoModelDiscussionUpdateReplyMessage === null ||
      orgSagebionetworksRepoModelDiscussionUpdateReplyMessage === undefined
    ) {
      throw new Error(
        'Required parameter orgSagebionetworksRepoModelDiscussionUpdateReplyMessage was null or undefined when calling putRepoV1ReplyReplyIdMessage.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/reply/${this.configuration.encodeParam({ name: 'replyId', value: replyId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/message`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionDiscussionReplyBundle>(
      'put',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: orgSagebionetworksRepoModelDiscussionUpdateReplyMessage,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param threadId - The ID of the thread being updated
   * @param orgSagebionetworksRepoModelDiscussionUpdateThreadMessage
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public putRepoV1ThreadThreadIdMessage(
    threadId: string,
    orgSagebionetworksRepoModelDiscussionUpdateThreadMessage: OrgSagebionetworksRepoModelDiscussionUpdateThreadMessage,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>;
  public putRepoV1ThreadThreadIdMessage(
    threadId: string,
    orgSagebionetworksRepoModelDiscussionUpdateThreadMessage: OrgSagebionetworksRepoModelDiscussionUpdateThreadMessage,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>>;
  public putRepoV1ThreadThreadIdMessage(
    threadId: string,
    orgSagebionetworksRepoModelDiscussionUpdateThreadMessage: OrgSagebionetworksRepoModelDiscussionUpdateThreadMessage,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>>;
  public putRepoV1ThreadThreadIdMessage(
    threadId: string,
    orgSagebionetworksRepoModelDiscussionUpdateThreadMessage: OrgSagebionetworksRepoModelDiscussionUpdateThreadMessage,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling putRepoV1ThreadThreadIdMessage.',
      );
    }
    if (
      orgSagebionetworksRepoModelDiscussionUpdateThreadMessage === null ||
      orgSagebionetworksRepoModelDiscussionUpdateThreadMessage === undefined
    ) {
      throw new Error(
        'Required parameter orgSagebionetworksRepoModelDiscussionUpdateThreadMessage was null or undefined when calling putRepoV1ThreadThreadIdMessage.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/thread/${this.configuration.encodeParam({ name: 'threadId', value: threadId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/message`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>(
      'put',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: orgSagebionetworksRepoModelDiscussionUpdateThreadMessage,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param threadId - the ID of the thread being marked as pinned
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public putRepoV1ThreadThreadIdPin(
    threadId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<any>;
  public putRepoV1ThreadThreadIdPin(
    threadId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<HttpResponse<any>>;
  public putRepoV1ThreadThreadIdPin(
    threadId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<HttpEvent<any>>;
  public putRepoV1ThreadThreadIdPin(
    threadId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<any> {
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling putRepoV1ThreadThreadIdPin.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/thread/${this.configuration.encodeParam({ name: 'threadId', value: threadId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/pin`;
    return this.httpClient.request<any>('put', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * @param threadId - the ID of the thread that was marked as deleted
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public putRepoV1ThreadThreadIdRestore(
    threadId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<any>;
  public putRepoV1ThreadThreadIdRestore(
    threadId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<HttpResponse<any>>;
  public putRepoV1ThreadThreadIdRestore(
    threadId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<HttpEvent<any>>;
  public putRepoV1ThreadThreadIdRestore(
    threadId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<any> {
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling putRepoV1ThreadThreadIdRestore.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/thread/${this.configuration.encodeParam({ name: 'threadId', value: threadId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/restore`;
    return this.httpClient.request<any>('put', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * @param threadId - The ID of the thread being updated
   * @param orgSagebionetworksRepoModelDiscussionUpdateThreadTitle
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public putRepoV1ThreadThreadIdTitle(
    threadId: string,
    orgSagebionetworksRepoModelDiscussionUpdateThreadTitle: OrgSagebionetworksRepoModelDiscussionUpdateThreadTitle,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>;
  public putRepoV1ThreadThreadIdTitle(
    threadId: string,
    orgSagebionetworksRepoModelDiscussionUpdateThreadTitle: OrgSagebionetworksRepoModelDiscussionUpdateThreadTitle,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>>;
  public putRepoV1ThreadThreadIdTitle(
    threadId: string,
    orgSagebionetworksRepoModelDiscussionUpdateThreadTitle: OrgSagebionetworksRepoModelDiscussionUpdateThreadTitle,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>>;
  public putRepoV1ThreadThreadIdTitle(
    threadId: string,
    orgSagebionetworksRepoModelDiscussionUpdateThreadTitle: OrgSagebionetworksRepoModelDiscussionUpdateThreadTitle,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling putRepoV1ThreadThreadIdTitle.',
      );
    }
    if (
      orgSagebionetworksRepoModelDiscussionUpdateThreadTitle === null ||
      orgSagebionetworksRepoModelDiscussionUpdateThreadTitle === undefined
    ) {
      throw new Error(
        'Required parameter orgSagebionetworksRepoModelDiscussionUpdateThreadTitle was null or undefined when calling putRepoV1ThreadThreadIdTitle.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json'];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/thread/${this.configuration.encodeParam({ name: 'threadId', value: threadId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/title`;
    return this.httpClient.request<OrgSagebionetworksRepoModelDiscussionDiscussionThreadBundle>(
      'put',
      `${this.configuration.basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: orgSagebionetworksRepoModelDiscussionUpdateThreadTitle,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * @param threadId - the ID of the thread being unpinned
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public putRepoV1ThreadThreadIdUnpin(
    threadId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<any>;
  public putRepoV1ThreadThreadIdUnpin(
    threadId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<HttpResponse<any>>;
  public putRepoV1ThreadThreadIdUnpin(
    threadId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<HttpEvent<any>>;
  public putRepoV1ThreadThreadIdUnpin(
    threadId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext; transferCache?: boolean },
  ): Observable<any> {
    if (threadId === null || threadId === undefined) {
      throw new Error(
        'Required parameter threadId was null or undefined when calling putRepoV1ThreadThreadIdUnpin.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (bearerAuth) required
    localVarCredential = this.configuration.lookupCredential('bearerAuth');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
    }

    let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    let localVarHttpContext: HttpContext | undefined = options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let localVarTransferCache: boolean | undefined = options && options.transferCache;
    if (localVarTransferCache === undefined) {
      localVarTransferCache = true;
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/repo/v1/thread/${this.configuration.encodeParam({ name: 'threadId', value: threadId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/unpin`;
    return this.httpClient.request<any>('put', `${this.configuration.basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }
}
