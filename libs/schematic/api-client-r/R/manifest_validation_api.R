#' Schematic REST API
#'
#' No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#'
#' The version of the OpenAPI document: 0.1.0
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title ManifestValidation operations
#' @description ManifestValidationApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ SubmitManifestCsv } \emph{ Validates manifest in csv form, then submits it }
#' Validates manifest in csv form, then submits it
#'
#' \itemize{
#' \item \emph{ @param } schema_url character
#' \item \emph{ @param } component character
#' \item \emph{ @param } dataset_id character
#' \item \emph{ @param } asset_view_id character
#' \item \emph{ @param } body data.frame
#' \item \emph{ @param } restrict_rules character
#' \item \emph{ @param } storage_method Enum < [file_and_entities, table_and_file, file_only, table_file_and_entities] >
#' \item \emph{ @param } hide_blanks character
#' \item \emph{ @param } table_manipulation_method Enum < [replace, upsert] >
#' \item \emph{ @param } use_schema_label character
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : character
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | The request cannot be fulfilled due to an unexpected server error
#'
#' \item return type : BasicError
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ SubmitManifestJson } \emph{ Validates a manifest in json form, then submits it }
#' Validates a manifest in json form, then submits it in csv form
#'
#' \itemize{
#' \item \emph{ @param } schema_url character
#' \item \emph{ @param } component character
#' \item \emph{ @param } dataset_id character
#' \item \emph{ @param } asset_view_id character
#' \item \emph{ @param } restrict_rules character
#' \item \emph{ @param } storage_method Enum < [file_and_entities, table_and_file, file_only, table_file_and_entities] >
#' \item \emph{ @param } hide_blanks character
#' \item \emph{ @param } table_manipulation_method Enum < [replace, upsert] >
#' \item \emph{ @param } use_schema_label character
#' \item \emph{ @param } body character
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : character
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | The request cannot be fulfilled due to an unexpected server error
#'
#' \item return type : BasicError
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ValidateManifestCsv } \emph{ Validates a manifest in csv form }
#' Validates a manifest in csv form
#'
#' \itemize{
#' \item \emph{ @param } schema_url character
#' \item \emph{ @param } component_label character
#' \item \emph{ @param } body data.frame
#' \item \emph{ @param } restrict_rules character
#' \item \emph{ @returnType } \link{ManifestValidationResult} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : ManifestValidationResult
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | The request cannot be fulfilled due to an unexpected server error
#'
#' \item return type : BasicError
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ValidateManifestJson } \emph{ Validates a manifest in json form }
#' Validates a manifest in json form
#'
#' \itemize{
#' \item \emph{ @param } schema_url character
#' \item \emph{ @param } component_label character
#' \item \emph{ @param } restrict_rules character
#' \item \emph{ @param } body character
#' \item \emph{ @returnType } \link{ManifestValidationResult} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : ManifestValidationResult
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | The request cannot be fulfilled due to an unexpected server error
#'
#' \item return type : BasicError
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  SubmitManifestCsv  ####################
#'
#' library(openapi)
#' var_schema_url <- "schema_url_example" # character | The URL of a schema in jsonld or csv form
#' var_component <- "component_example" # character | A component in a schema, either the dsplay label or schema label
#' var_dataset_id <- "dataset_id_example" # character | The ID of a dataset.
#' var_asset_view_id <- "asset_view_id_example" # character | ID of view listing all project data assets. E.g. for Synapse this would be the Synapse ID of the fileview listing all data assets for a given project
#' var_body <- File.new('/path/to/file') # data.frame | .csv file
#' var_restrict_rules <- FALSE # character | If True, validation suite will only run with in-house validation rule. If False, the Great Expectations suite will be utilized and all rules will be available. (Optional)
#' var_storage_method <- "table_file_and_entities" # character | file_and_entities will store the manifest as a csv and create Synapse files for each row in the manifest. table_and_file will store the manifest as a table and a csv on Synapse. file_only will store the manifest as a csv only on Synapse. table_file_and_entities will perform the options file_with_entites and table in combination. (Optional)
#' var_hide_blanks <- FALSE # character | If true, annotations with blank values will be hidden from a dataset's annotation list in Synaspe. If false, annotations with blank values will be displayed. (Optional)
#' var_table_manipulation_method <- "replace" # character | replace will remove the rows and columns from the existing table and store the new rows and columns, preserving the name and synID. upsert will add the new rows to the table and preserve the exisitng rows and columns in the existing table. (Optional)
#' var_use_schema_label <- TRUE # character | If true, store attributes using the schema label If false, store attributes using the display label (Optional)
#'
#' #Validates manifest in csv form, then submits it
#' api_instance <- ManifestValidationApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SubmitManifestCsv(var_schema_url, var_component, var_dataset_id, var_asset_view_id, var_body, restrict_rules = var_restrict_rules, storage_method = var_storage_method, hide_blanks = var_hide_blanks, table_manipulation_method = var_table_manipulation_method, use_schema_label = var_use_schema_labeldata_file = "result.txt")
#' result <- api_instance$SubmitManifestCsv(var_schema_url, var_component, var_dataset_id, var_asset_view_id, var_body, restrict_rules = var_restrict_rules, storage_method = var_storage_method, hide_blanks = var_hide_blanks, table_manipulation_method = var_table_manipulation_method, use_schema_label = var_use_schema_label)
#' dput(result)
#'
#'
#' ####################  SubmitManifestJson  ####################
#'
#' library(openapi)
#' var_schema_url <- "schema_url_example" # character | The URL of a schema in jsonld or csv form
#' var_component <- "component_example" # character | A component in a schema, either the dsplay label or schema label
#' var_dataset_id <- "dataset_id_example" # character | The ID of a dataset.
#' var_asset_view_id <- "asset_view_id_example" # character | ID of view listing all project data assets. E.g. for Synapse this would be the Synapse ID of the fileview listing all data assets for a given project
#' var_restrict_rules <- FALSE # character | If True, validation suite will only run with in-house validation rule. If False, the Great Expectations suite will be utilized and all rules will be available. (Optional)
#' var_storage_method <- "table_file_and_entities" # character | file_and_entities will store the manifest as a csv and create Synapse files for each row in the manifest. table_and_file will store the manifest as a table and a csv on Synapse. file_only will store the manifest as a csv only on Synapse. table_file_and_entities will perform the options file_with_entites and table in combination. (Optional)
#' var_hide_blanks <- FALSE # character | If true, annotations with blank values will be hidden from a dataset's annotation list in Synaspe. If false, annotations with blank values will be displayed. (Optional)
#' var_table_manipulation_method <- "replace" # character | replace will remove the rows and columns from the existing table and store the new rows and columns, preserving the name and synID. upsert will add the new rows to the table and preserve the exisitng rows and columns in the existing table. (Optional)
#' var_use_schema_label <- TRUE # character | If true, store attributes using the schema label If false, store attributes using the display label (Optional)
#' var_body <- "body_example" # character | A manifest in json form (Optional)
#'
#' #Validates a manifest in json form, then submits it
#' api_instance <- ManifestValidationApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SubmitManifestJson(var_schema_url, var_component, var_dataset_id, var_asset_view_id, restrict_rules = var_restrict_rules, storage_method = var_storage_method, hide_blanks = var_hide_blanks, table_manipulation_method = var_table_manipulation_method, use_schema_label = var_use_schema_label, body = var_bodydata_file = "result.txt")
#' result <- api_instance$SubmitManifestJson(var_schema_url, var_component, var_dataset_id, var_asset_view_id, restrict_rules = var_restrict_rules, storage_method = var_storage_method, hide_blanks = var_hide_blanks, table_manipulation_method = var_table_manipulation_method, use_schema_label = var_use_schema_label, body = var_body)
#' dput(result)
#'
#'
#' ####################  ValidateManifestCsv  ####################
#'
#' library(openapi)
#' var_schema_url <- "schema_url_example" # character | The URL of a schema in jsonld or csv form
#' var_component_label <- "component_label_example" # character | The label of a component in a schema
#' var_body <- File.new('/path/to/file') # data.frame | .csv file
#' var_restrict_rules <- FALSE # character | If True, validation suite will only run with in-house validation rule. If False, the Great Expectations suite will be utilized and all rules will be available. (Optional)
#'
#' #Validates a manifest in csv form
#' api_instance <- ManifestValidationApi$new()
#'
#' # Configure HTTP bearer authorization: bearerAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$ValidateManifestCsv(var_schema_url, var_component_label, var_body, restrict_rules = var_restrict_rulesdata_file = "result.txt")
#' result <- api_instance$ValidateManifestCsv(var_schema_url, var_component_label, var_body, restrict_rules = var_restrict_rules)
#' dput(result)
#'
#'
#' ####################  ValidateManifestJson  ####################
#'
#' library(openapi)
#' var_schema_url <- "schema_url_example" # character | The URL of a schema in jsonld or csv form
#' var_component_label <- "component_label_example" # character | The label of a component in a schema
#' var_restrict_rules <- FALSE # character | If True, validation suite will only run with in-house validation rule. If False, the Great Expectations suite will be utilized and all rules will be available. (Optional)
#' var_body <- "body_example" # character | A manifest in json form (Optional)
#'
#' #Validates a manifest in json form
#' api_instance <- ManifestValidationApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$ValidateManifestJson(var_schema_url, var_component_label, restrict_rules = var_restrict_rules, body = var_bodydata_file = "result.txt")
#' result <- api_instance$ValidateManifestJson(var_schema_url, var_component_label, restrict_rules = var_restrict_rules, body = var_body)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
ManifestValidationApi <- R6::R6Class(
  "ManifestValidationApi",
  public = list(
    api_client = NULL,
    #' Initialize a new ManifestValidationApi.
    #'
    #' @description
    #' Initialize a new ManifestValidationApi.
    #'
    #' @param api_client An instance of API client.
    #' @export
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },
    #' Validates manifest in csv form, then submits it
    #'
    #' @description
    #' Validates manifest in csv form, then submits it
    #'
    #' @param schema_url The URL of a schema in jsonld or csv form
    #' @param component A component in a schema, either the dsplay label or schema label
    #' @param dataset_id The ID of a dataset.
    #' @param asset_view_id ID of view listing all project data assets. E.g. for Synapse this would be the Synapse ID of the fileview listing all data assets for a given project
    #' @param body .csv file
    #' @param restrict_rules (optional) If True, validation suite will only run with in-house validation rule. If False, the Great Expectations suite will be utilized and all rules will be available. (default value: FALSE)
    #' @param storage_method (optional) file_and_entities will store the manifest as a csv and create Synapse files for each row in the manifest. table_and_file will store the manifest as a table and a csv on Synapse. file_only will store the manifest as a csv only on Synapse. table_file_and_entities will perform the options file_with_entites and table in combination. (default value: "table_file_and_entities")
    #' @param hide_blanks (optional) If true, annotations with blank values will be hidden from a dataset's annotation list in Synaspe. If false, annotations with blank values will be displayed. (default value: FALSE)
    #' @param table_manipulation_method (optional) replace will remove the rows and columns from the existing table and store the new rows and columns, preserving the name and synID. upsert will add the new rows to the table and preserve the exisitng rows and columns in the existing table. (default value: "replace")
    #' @param use_schema_label (optional) If true, store attributes using the schema label If false, store attributes using the display label (default value: TRUE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return character
    #' @export
    SubmitManifestCsv = function(schema_url, component, dataset_id, asset_view_id, body, restrict_rules = FALSE, storage_method = "table_file_and_entities", hide_blanks = FALSE, table_manipulation_method = "replace", use_schema_label = TRUE, data_file = NULL, ...) {
      local_var_response <- self$SubmitManifestCsvWithHttpInfo(schema_url, component, dataset_id, asset_view_id, body, restrict_rules, storage_method, hide_blanks, table_manipulation_method, use_schema_label, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Validates manifest in csv form, then submits it
    #'
    #' @description
    #' Validates manifest in csv form, then submits it
    #'
    #' @param schema_url The URL of a schema in jsonld or csv form
    #' @param component A component in a schema, either the dsplay label or schema label
    #' @param dataset_id The ID of a dataset.
    #' @param asset_view_id ID of view listing all project data assets. E.g. for Synapse this would be the Synapse ID of the fileview listing all data assets for a given project
    #' @param body .csv file
    #' @param restrict_rules (optional) If True, validation suite will only run with in-house validation rule. If False, the Great Expectations suite will be utilized and all rules will be available. (default value: FALSE)
    #' @param storage_method (optional) file_and_entities will store the manifest as a csv and create Synapse files for each row in the manifest. table_and_file will store the manifest as a table and a csv on Synapse. file_only will store the manifest as a csv only on Synapse. table_file_and_entities will perform the options file_with_entites and table in combination. (default value: "table_file_and_entities")
    #' @param hide_blanks (optional) If true, annotations with blank values will be hidden from a dataset's annotation list in Synaspe. If false, annotations with blank values will be displayed. (default value: FALSE)
    #' @param table_manipulation_method (optional) replace will remove the rows and columns from the existing table and store the new rows and columns, preserving the name and synID. upsert will add the new rows to the table and preserve the exisitng rows and columns in the existing table. (default value: "replace")
    #' @param use_schema_label (optional) If true, store attributes using the schema label If false, store attributes using the display label (default value: TRUE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (character) with additional information such as HTTP status code, headers
    #' @export
    SubmitManifestCsvWithHttpInfo = function(schema_url, component, dataset_id, asset_view_id, body, restrict_rules = FALSE, storage_method = "table_file_and_entities", hide_blanks = FALSE, table_manipulation_method = "replace", use_schema_label = TRUE, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`schema_url`)) {
        stop("Missing required parameter `schema_url`.")
      }

      if (missing(`component`)) {
        stop("Missing required parameter `component`.")
      }

      if (missing(`dataset_id`)) {
        stop("Missing required parameter `dataset_id`.")
      }

      if (missing(`asset_view_id`)) {
        stop("Missing required parameter `asset_view_id`.")
      }

      if (missing(`body`)) {
        stop("Missing required parameter `body`.")
      }











      query_params[["schemaUrl"]] <- `schema_url`

      query_params[["component"]] <- `component`

      query_params[["restrictRules"]] <- `restrict_rules`

      query_params[["datasetId"]] <- `dataset_id`

      if (!(`storage_method` %in% c("file_and_entities", "table_and_file", "file_only", "table_file_and_entities"))) {
        stop("Invalid value for storage_method when calling ManifestValidationApi$SubmitManifestCsv. Must be [file_and_entities, table_and_file, file_only, table_file_and_entities].")
      }
      query_params[["storageMethod"]] <- `storage_method`

      query_params[["hideBlanks"]] <- `hide_blanks`

      query_params[["assetViewId"]] <- `asset_view_id`

      if (!(`table_manipulation_method` %in% c("replace", "upsert"))) {
        stop("Invalid value for table_manipulation_method when calling ManifestValidationApi$SubmitManifestCsv. Must be [replace, upsert].")
      }
      query_params[["tableManipulationMethod"]] <- `table_manipulation_method`

      query_params[["useSchemaLabel"]] <- `use_schema_label`

      if (!is.null(`body`)) {
        local_var_body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/submitManifestCsv"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list("application/csv")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "character", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Validates a manifest in json form, then submits it
    #'
    #' @description
    #' Validates a manifest in json form, then submits it
    #'
    #' @param schema_url The URL of a schema in jsonld or csv form
    #' @param component A component in a schema, either the dsplay label or schema label
    #' @param dataset_id The ID of a dataset.
    #' @param asset_view_id ID of view listing all project data assets. E.g. for Synapse this would be the Synapse ID of the fileview listing all data assets for a given project
    #' @param restrict_rules (optional) If True, validation suite will only run with in-house validation rule. If False, the Great Expectations suite will be utilized and all rules will be available. (default value: FALSE)
    #' @param storage_method (optional) file_and_entities will store the manifest as a csv and create Synapse files for each row in the manifest. table_and_file will store the manifest as a table and a csv on Synapse. file_only will store the manifest as a csv only on Synapse. table_file_and_entities will perform the options file_with_entites and table in combination. (default value: "table_file_and_entities")
    #' @param hide_blanks (optional) If true, annotations with blank values will be hidden from a dataset's annotation list in Synaspe. If false, annotations with blank values will be displayed. (default value: FALSE)
    #' @param table_manipulation_method (optional) replace will remove the rows and columns from the existing table and store the new rows and columns, preserving the name and synID. upsert will add the new rows to the table and preserve the exisitng rows and columns in the existing table. (default value: "replace")
    #' @param use_schema_label (optional) If true, store attributes using the schema label If false, store attributes using the display label (default value: TRUE)
    #' @param body (optional) A manifest in json form
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return character
    #' @export
    SubmitManifestJson = function(schema_url, component, dataset_id, asset_view_id, restrict_rules = FALSE, storage_method = "table_file_and_entities", hide_blanks = FALSE, table_manipulation_method = "replace", use_schema_label = TRUE, body = NULL, data_file = NULL, ...) {
      local_var_response <- self$SubmitManifestJsonWithHttpInfo(schema_url, component, dataset_id, asset_view_id, restrict_rules, storage_method, hide_blanks, table_manipulation_method, use_schema_label, body, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Validates a manifest in json form, then submits it
    #'
    #' @description
    #' Validates a manifest in json form, then submits it
    #'
    #' @param schema_url The URL of a schema in jsonld or csv form
    #' @param component A component in a schema, either the dsplay label or schema label
    #' @param dataset_id The ID of a dataset.
    #' @param asset_view_id ID of view listing all project data assets. E.g. for Synapse this would be the Synapse ID of the fileview listing all data assets for a given project
    #' @param restrict_rules (optional) If True, validation suite will only run with in-house validation rule. If False, the Great Expectations suite will be utilized and all rules will be available. (default value: FALSE)
    #' @param storage_method (optional) file_and_entities will store the manifest as a csv and create Synapse files for each row in the manifest. table_and_file will store the manifest as a table and a csv on Synapse. file_only will store the manifest as a csv only on Synapse. table_file_and_entities will perform the options file_with_entites and table in combination. (default value: "table_file_and_entities")
    #' @param hide_blanks (optional) If true, annotations with blank values will be hidden from a dataset's annotation list in Synaspe. If false, annotations with blank values will be displayed. (default value: FALSE)
    #' @param table_manipulation_method (optional) replace will remove the rows and columns from the existing table and store the new rows and columns, preserving the name and synID. upsert will add the new rows to the table and preserve the exisitng rows and columns in the existing table. (default value: "replace")
    #' @param use_schema_label (optional) If true, store attributes using the schema label If false, store attributes using the display label (default value: TRUE)
    #' @param body (optional) A manifest in json form
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (character) with additional information such as HTTP status code, headers
    #' @export
    SubmitManifestJsonWithHttpInfo = function(schema_url, component, dataset_id, asset_view_id, restrict_rules = FALSE, storage_method = "table_file_and_entities", hide_blanks = FALSE, table_manipulation_method = "replace", use_schema_label = TRUE, body = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`schema_url`)) {
        stop("Missing required parameter `schema_url`.")
      }

      if (missing(`component`)) {
        stop("Missing required parameter `component`.")
      }

      if (missing(`dataset_id`)) {
        stop("Missing required parameter `dataset_id`.")
      }

      if (missing(`asset_view_id`)) {
        stop("Missing required parameter `asset_view_id`.")
      }











      query_params[["schemaUrl"]] <- `schema_url`

      query_params[["component"]] <- `component`

      query_params[["restrictRules"]] <- `restrict_rules`

      query_params[["datasetId"]] <- `dataset_id`

      if (!(`storage_method` %in% c("file_and_entities", "table_and_file", "file_only", "table_file_and_entities"))) {
        stop("Invalid value for storage_method when calling ManifestValidationApi$SubmitManifestJson. Must be [file_and_entities, table_and_file, file_only, table_file_and_entities].")
      }
      query_params[["storageMethod"]] <- `storage_method`

      query_params[["hideBlanks"]] <- `hide_blanks`

      query_params[["assetViewId"]] <- `asset_view_id`

      if (!(`table_manipulation_method` %in% c("replace", "upsert"))) {
        stop("Invalid value for table_manipulation_method when calling ManifestValidationApi$SubmitManifestJson. Must be [replace, upsert].")
      }
      query_params[["tableManipulationMethod"]] <- `table_manipulation_method`

      query_params[["useSchemaLabel"]] <- `use_schema_label`

      if (!is.null(`body`)) {
        local_var_body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/submitManifestJson"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list("text/plain")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "character", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Validates a manifest in csv form
    #'
    #' @description
    #' Validates a manifest in csv form
    #'
    #' @param schema_url The URL of a schema in jsonld or csv form
    #' @param component_label The label of a component in a schema
    #' @param body .csv file
    #' @param restrict_rules (optional) If True, validation suite will only run with in-house validation rule. If False, the Great Expectations suite will be utilized and all rules will be available. (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ManifestValidationResult
    #' @export
    ValidateManifestCsv = function(schema_url, component_label, body, restrict_rules = FALSE, data_file = NULL, ...) {
      local_var_response <- self$ValidateManifestCsvWithHttpInfo(schema_url, component_label, body, restrict_rules, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Validates a manifest in csv form
    #'
    #' @description
    #' Validates a manifest in csv form
    #'
    #' @param schema_url The URL of a schema in jsonld or csv form
    #' @param component_label The label of a component in a schema
    #' @param body .csv file
    #' @param restrict_rules (optional) If True, validation suite will only run with in-house validation rule. If False, the Great Expectations suite will be utilized and all rules will be available. (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ManifestValidationResult) with additional information such as HTTP status code, headers
    #' @export
    ValidateManifestCsvWithHttpInfo = function(schema_url, component_label, body, restrict_rules = FALSE, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`schema_url`)) {
        stop("Missing required parameter `schema_url`.")
      }

      if (missing(`component_label`)) {
        stop("Missing required parameter `component_label`.")
      }

      if (missing(`body`)) {
        stop("Missing required parameter `body`.")
      }





      query_params[["schemaUrl"]] <- `schema_url`

      query_params[["componentLabel"]] <- `component_label`

      query_params[["restrictRules"]] <- `restrict_rules`

      if (!is.null(`body`)) {
        local_var_body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/validateManifestCsv"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list("application/csv")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ManifestValidationResult", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    },
    #' Validates a manifest in json form
    #'
    #' @description
    #' Validates a manifest in json form
    #'
    #' @param schema_url The URL of a schema in jsonld or csv form
    #' @param component_label The label of a component in a schema
    #' @param restrict_rules (optional) If True, validation suite will only run with in-house validation rule. If False, the Great Expectations suite will be utilized and all rules will be available. (default value: FALSE)
    #' @param body (optional) A manifest in json form
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return ManifestValidationResult
    #' @export
    ValidateManifestJson = function(schema_url, component_label, restrict_rules = FALSE, body = NULL, data_file = NULL, ...) {
      local_var_response <- self$ValidateManifestJsonWithHttpInfo(schema_url, component_label, restrict_rules, body, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        local_var_response$content
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        local_var_response
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        local_var_response
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        local_var_response
      }
    },
    #' Validates a manifest in json form
    #'
    #' @description
    #' Validates a manifest in json form
    #'
    #' @param schema_url The URL of a schema in jsonld or csv form
    #' @param component_label The label of a component in a schema
    #' @param restrict_rules (optional) If True, validation suite will only run with in-house validation rule. If False, the Great Expectations suite will be utilized and all rules will be available. (default value: FALSE)
    #' @param body (optional) A manifest in json form
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @return API response (ManifestValidationResult) with additional information such as HTTP status code, headers
    #' @export
    ValidateManifestJsonWithHttpInfo = function(schema_url, component_label, restrict_rules = FALSE, body = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`schema_url`)) {
        stop("Missing required parameter `schema_url`.")
      }

      if (missing(`component_label`)) {
        stop("Missing required parameter `component_label`.")
      }





      query_params[["schemaUrl"]] <- `schema_url`

      query_params[["componentLabel"]] <- `component_label`

      query_params[["restrictRules"]] <- `restrict_rules`

      if (!is.null(`body`)) {
        local_var_body <- `body`$toJSONString()
      } else {
        body <- NULL
      }

      local_var_url_path <- "/validateManifestJson"

      # The Accept request HTTP header
      local_var_accepts <- list("application/json", "application/problem+json")

      # The Content-Type representation header
      local_var_content_types <- list("text/plain")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          write(local_var_resp$response, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$deserialize(local_var_resp$response, "ManifestValidationResult", loadNamespace("openapi")),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        local_var_resp
      } else if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        local_var_resp
      }
    }
  )
)
