# coding: utf-8

"""
OpenChallenges API

Discover, explore, and contribute to open biomedical challenges.

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from uuid import UUID
from typing import Optional, Set
from typing_extensions import Self


class CreateApiKeyResponse(BaseModel):
    """
    CreateApiKeyResponse
    """  # noqa: E501

    id: Optional[UUID] = Field(default=None, description="API key ID")
    key: Optional[StrictStr] = Field(
        default=None, description="The actual API key (only returned on creation)"
    )
    name: Optional[StrictStr] = Field(
        default=None, description="Human-readable name for the API key"
    )
    prefix: Optional[StrictStr] = Field(
        default=None, description="First 8 characters of the API key for identification"
    )
    created_at: Optional[datetime] = Field(
        default=None, description="When the API key was created", alias="createdAt"
    )
    expires_at: Optional[datetime] = Field(
        default=None,
        description="When the API key expires (null if no expiration)",
        alias="expiresAt",
    )
    __properties: ClassVar[List[str]] = [
        "id",
        "key",
        "name",
        "prefix",
        "createdAt",
        "expiresAt",
    ]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreateApiKeyResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if expires_at (nullable) is None
        # and model_fields_set contains the field
        if self.expires_at is None and "expires_at" in self.model_fields_set:
            _dict["expiresAt"] = None

        return _dict

    # --- BEGIN CUSTOM: tolerant construction helper for page-like list models ---
    @classmethod
    def from_dict_skip_invalid(cls, obj: Optional[Dict[str, Any]]):  # type: ignore[override]
        """Create instance skipping invalid nested items (Page models only).

        Heuristics:
        - Applies only when the class name ends with 'Page'.
        - Identifies the primary list field ("organizations", "items", or the only list field).
        - Attempts per-item validation; invalid items (including those with additional fields
          or field constraint violations) are skipped.
        - Attaches counts via `_skipped_invalid_items` and `_skipped_invalid_organizations` (legacy).
        Fallbacks to strict parsing if structure is unexpected to avoid masking systemic issues.
        """
        if not getattr(cls, "__name__", "").endswith("Page"):
            return cls.from_dict(obj)  # type: ignore
        if obj is None or not isinstance(obj, dict):
            return cls.from_dict(obj)  # type: ignore

        # Detect candidate list fields.
        candidate_keys = [k for k, v in obj.items() if isinstance(v, list)]
        target_key = None
        for preferred in ("organizations", "items"):
            if preferred in candidate_keys:
                target_key = preferred
                break
        if target_key is None and len(candidate_keys) == 1:
            target_key = candidate_keys[0]
        if target_key is None:
            return cls.from_dict(obj)  # type: ignore

        raw_list = obj.get(target_key) or []
        # Infer element model class from pydantic field annotation if possible.
        element_model = None
        try:  # best-effort; failures fall back to dict passthrough
            from typing import get_args  # Python 3.11+ stdlib

            field_info = getattr(cls, "model_fields", {}).get(target_key)
            if field_info is not None:
                ann = getattr(field_info, "annotation", None)
                if ann is not None:
                    args = get_args(ann)
                    if args:
                        element_model = args[0]
        except Exception:  # pragma: no cover
            element_model = None

        parsed_models = []
        skipped = 0
        for entry in raw_list:
            # Normalize to dict for validation if possible
            candidate = entry
            if isinstance(entry, tuple):  # unlikely but defensively handle
                # Convert tuples to list/dict only if element model expects mapping; else keep
                candidate = entry
            try:
                if (
                    element_model is not None
                    and hasattr(element_model, "from_dict")
                    and isinstance(candidate, dict)
                ):
                    model_obj = element_model.from_dict(candidate)
                elif element_model is not None and hasattr(
                    element_model, "model_validate"
                ):  # pydantic BaseModel subclass
                    model_obj = element_model.model_validate(candidate)
                else:
                    # No element model – accept as-is (will validate later or be skipped if invalid)
                    model_obj = candidate
                if model_obj is None:
                    skipped += 1
                else:
                    parsed_models.append(model_obj)
            except Exception:  # validation error – skip
                skipped += 1

        # Rebuild object dict with validated subset
        tmp = dict(obj)
        tmp[target_key] = parsed_models
        try:
            inst = cls.from_dict(tmp)  # type: ignore
        except Exception:
            # As a last resort fall back to strict path (may raise), to avoid silent data loss at page level
            return cls.from_dict(obj)  # type: ignore

        if inst is not None and skipped:
            setattr(inst, "_skipped_invalid_items", skipped)
            setattr(inst, "_skipped_invalid_organizations", skipped)
        return inst

    # --- END CUSTOM ---

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreateApiKeyResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "id": obj.get("id"),
                "key": obj.get("key"),
                "name": obj.get("name"),
                "prefix": obj.get("prefix"),
                "createdAt": obj.get("createdAt"),
                "expiresAt": obj.get("expiresAt"),
            }
        )
        return _obj
