/*
 * OpenChallenges REST API
 * Discover, explore, and contribute to open biomedical challenges.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.sagebionetworks.openchallenges.api.client.model;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

/**
 * An object
 */
@JsonPropertyOrder(
  {
    ChallengesPerYear.JSON_PROPERTY_YEARS,
    ChallengesPerYear.JSON_PROPERTY_CHALLENGE_COUNTS,
    ChallengesPerYear.JSON_PROPERTY_UNDATED_CHALLENGE_COUNT,
  }
)
@jakarta.annotation.Generated(
  value = "org.openapitools.codegen.languages.JavaClientCodegen",
  comments = "Generator version: 7.13.0"
)
public class ChallengesPerYear {

  public static final String JSON_PROPERTY_YEARS = "years";

  @jakarta.annotation.Nonnull
  private List<String> years = new ArrayList<>();

  public static final String JSON_PROPERTY_CHALLENGE_COUNTS = "challengeCounts";

  @jakarta.annotation.Nonnull
  private List<Integer> challengeCounts = new ArrayList<>();

  public static final String JSON_PROPERTY_UNDATED_CHALLENGE_COUNT = "undatedChallengeCount";

  @jakarta.annotation.Nonnull
  private Integer undatedChallengeCount = 0;

  public ChallengesPerYear() {}

  public ChallengesPerYear years(@jakarta.annotation.Nonnull List<String> years) {
    this.years = years;
    return this;
  }

  public ChallengesPerYear addYearsItem(String yearsItem) {
    if (this.years == null) {
      this.years = new ArrayList<>();
    }
    this.years.add(yearsItem);
    return this;
  }

  /**
   * Get years
   * @return years
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_YEARS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<String> getYears() {
    return years;
  }

  @JsonProperty(JSON_PROPERTY_YEARS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setYears(@jakarta.annotation.Nonnull List<String> years) {
    this.years = years;
  }

  public ChallengesPerYear challengeCounts(
    @jakarta.annotation.Nonnull List<Integer> challengeCounts
  ) {
    this.challengeCounts = challengeCounts;
    return this;
  }

  public ChallengesPerYear addChallengeCountsItem(Integer challengeCountsItem) {
    if (this.challengeCounts == null) {
      this.challengeCounts = new ArrayList<>();
    }
    this.challengeCounts.add(challengeCountsItem);
    return this;
  }

  /**
   * Get challengeCounts
   * @return challengeCounts
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_CHALLENGE_COUNTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<Integer> getChallengeCounts() {
    return challengeCounts;
  }

  @JsonProperty(JSON_PROPERTY_CHALLENGE_COUNTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setChallengeCounts(@jakarta.annotation.Nonnull List<Integer> challengeCounts) {
    this.challengeCounts = challengeCounts;
  }

  public ChallengesPerYear undatedChallengeCount(
    @jakarta.annotation.Nonnull Integer undatedChallengeCount
  ) {
    this.undatedChallengeCount = undatedChallengeCount;
    return this;
  }

  /**
   * Get undatedChallengeCount
   * minimum: 0
   * @return undatedChallengeCount
   */
  @jakarta.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_UNDATED_CHALLENGE_COUNT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Integer getUndatedChallengeCount() {
    return undatedChallengeCount;
  }

  @JsonProperty(JSON_PROPERTY_UNDATED_CHALLENGE_COUNT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setUndatedChallengeCount(@jakarta.annotation.Nonnull Integer undatedChallengeCount) {
    this.undatedChallengeCount = undatedChallengeCount;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ChallengesPerYear challengesPerYear = (ChallengesPerYear) o;
    return (
      Objects.equals(this.years, challengesPerYear.years) &&
      Objects.equals(this.challengeCounts, challengesPerYear.challengeCounts) &&
      Objects.equals(this.undatedChallengeCount, challengesPerYear.undatedChallengeCount)
    );
  }

  @Override
  public int hashCode() {
    return Objects.hash(years, challengeCounts, undatedChallengeCount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ChallengesPerYear {\n");
    sb.append("    years: ").append(toIndentedString(years)).append("\n");
    sb.append("    challengeCounts: ").append(toIndentedString(challengeCounts)).append("\n");
    sb
      .append("    undatedChallengeCount: ")
      .append(toIndentedString(undatedChallengeCount))
      .append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}
